import type {
  UIMessage as ChatMessage,
  StreamTextOnFinishCallback,
  ToolSet
} from "ai";
import { Agent, type AgentContext, type Connection, type WSMessage } from "./";
import {
  MessageType,
  type IncomingMessage,
  type OutgoingMessage
} from "./ai-types";

const decoder = new TextDecoder();

/**
 * Extension of Agent with built-in chat capabilities
 * @template Env Environment type containing bindings
 */
export class AIChatAgent<Env = unknown, State = unknown> extends Agent<
  Env,
  State
> {
  /**
   * Map of message `id`s to `AbortController`s
   * useful to propagate request cancellation signals for any external calls made by the agent
   */
  private _chatMessageAbortControllers: Map<string, AbortController>;
  /** Array of chat messages for the current conversation */
  messages: ChatMessage[];
  constructor(ctx: AgentContext, env: Env) {
    super(ctx, env);
    this.sql`create table if not exists cf_ai_chat_agent_messages (
      id text primary key,
      message text not null,
      created_at datetime default current_timestamp
    )`;
    this.messages = (
      this.sql`select * from cf_ai_chat_agent_messages` || []
    ).map((row) => {
      return JSON.parse(row.message as string);
    });

    this._chatMessageAbortControllers = new Map();
  }

  private _broadcastChatMessage(message: OutgoingMessage, exclude?: string[]) {
    this.broadcast(JSON.stringify(message), exclude);
  }

  override async onMessage(connection: Connection, message: WSMessage) {
    if (typeof message === "string") {
      let data: IncomingMessage;
      try {
        data = JSON.parse(message) as IncomingMessage;
      } catch (_error) {
        // silently ignore invalid messages for now
        // TODO: log errors with log levels
        return;
      }
      if (
        data.type === MessageType.CF_AGENT_USE_CHAT_REQUEST &&
        data.init.method === "POST"
      ) {
        const {
          // method,
          // keepalive,
          // headers,
          body // we're reading this
          //
          // // these might not exist?
          // dispatcher,
          // duplex
        } = data.init;
        const { messages } = JSON.parse(body as string);
        this._broadcastChatMessage(
          {
            messages,
            type: MessageType.CF_AGENT_CHAT_MESSAGES
          },
          [connection.id]
        );

        await this.persistMessages(messages, [connection.id]);

        this.observability?.emit(
          {
            displayMessage: "Chat message request",
            id: data.id,
            payload: {},
            timestamp: Date.now(),
            type: "message:request"
          },
          this.ctx
        );

        const chatMessageId = data.id;
        const abortSignal = this._getAbortSignal(chatMessageId);

        return this._tryCatchChat(async () => {
          const response = await this.onChatMessage(
            async () => {
              // In v5, we handle the result differently
              // The onFinish callback provides the complete result including messages
              this._removeAbortController(chatMessageId);

              this.observability?.emit(
                {
                  displayMessage: "Chat message response",
                  id: data.id,
                  payload: {},
                  timestamp: Date.now(),
                  type: "message:response"
                },
                this.ctx
              );
            },
            abortSignal ? { abortSignal } : undefined
          );

          if (response) {
            await this._reply(data.id, response);
          } else {
            // Log a warning for observability
            console.warn(
              `[AIChatAgent] onChatMessage returned no response for chatMessageId: ${chatMessageId}`
            );
            // Send a fallback message to the client
            this._broadcastChatMessage(
              {
                body: "No response was generated by the agent.",
                done: true,
                id: data.id,
                type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
              },
              [connection.id]
            );
          }
        });
      }
      if (data.type === MessageType.CF_AGENT_CHAT_CLEAR) {
        this._destroyAbortControllers();
        this.sql`delete from cf_ai_chat_agent_messages`;
        this.messages = [];
        this._broadcastChatMessage(
          {
            type: MessageType.CF_AGENT_CHAT_CLEAR
          },
          [connection.id]
        );
      } else if (data.type === MessageType.CF_AGENT_CHAT_MESSAGES) {
        // replace the messages with the new ones
        await this.persistMessages(data.messages, [connection.id]);
      } else if (data.type === MessageType.CF_AGENT_CHAT_REQUEST_CANCEL) {
        // propagate an abort signal for the associated request
        this._cancelChatRequest(data.id);
      }
    }
  }

  override async onRequest(request: Request): Promise<Response> {
    return this._tryCatchChat(() => {
      const url = new URL(request.url);
      if (url.pathname.endsWith("/get-messages")) {
        const messages = (
          this.sql`select * from cf_ai_chat_agent_messages` || []
        ).map((row) => {
          return JSON.parse(row.message as string);
        });
        return Response.json(messages);
      }
      return super.onRequest(request);
    });
  }

  private async _tryCatchChat<T>(fn: () => T | Promise<T>) {
    try {
      return await fn();
    } catch (e) {
      throw this.onError(e);
    }
  }

  private async _drainStream(stream: ReadableStream<Uint8Array>) {
    const reader = stream.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        decoder.decode(value);
      }
    } finally {
      reader.releaseLock();
    }
  }

  private async _processAndDrainStream(response: Response) {
    if (!response.body) return;

    const reader = response.body.getReader();
    let currentTextContent = "";
    const messageParts: Array<{ type: "text"; text: string }> = [];

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        const lines = chunk.split("\n");

        for (const line of lines) {
          if (!line.trim()) continue;

          // Handle AI SDK v5 format ("0:" prefix)
          if (line.startsWith("0:")) {
            try {
              const jsonPart = line.slice(2);
              const parsed = JSON.parse(jsonPart);

              if (parsed.type === "text-delta") {
                currentTextContent += parsed.textDelta || "";
              }
            } catch (_e) {
              // Ignore parsing errors
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }

    // Save the assistant's response
    if (currentTextContent) {
      messageParts.push({ type: "text", text: currentTextContent });
      await this.persistMessages([
        ...this.messages,
        {
          id: crypto.randomUUID(),
          role: "assistant",
          parts: messageParts
        } as ChatMessage
      ]);
    }
  }

  /**
   * Handle incoming chat messages and generate a response
   * @param onFinish Callback to be called when the response is finished
   * @param options.signal A signal to pass to any child requests which can be used to cancel them
   * @returns Response to send to the client or undefined
   */
  async onChatMessage(
    // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later
    onFinish: StreamTextOnFinishCallback<ToolSet>,
    // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later
    options?: { abortSignal: AbortSignal | undefined }
  ): Promise<Response | undefined> {
    throw new Error(
      "recieved a chat message, override onChatMessage and return a Response to send to the client"
    );
  }

  /**
   * Save messages on the server side and trigger AI response
   * @param messages Chat messages to save
   */
  async saveMessages(messages: ChatMessage[]) {
    await this.persistMessages(messages);
    const response = await this.onChatMessage(async () => {
      // In v5, persistence is handled after streaming is complete
      // The result contains the final messages
    });
    if (response?.body) {
      // Process and drain the response stream
      await this._processAndDrainStream(response);
    }
  }

  async persistMessages(
    messages: ChatMessage[],
    excludeBroadcastIds: string[] = []
  ) {
    this.sql`delete from cf_ai_chat_agent_messages`;
    for (const message of messages) {
      this.sql`insert into cf_ai_chat_agent_messages (id, message) values (${
        message.id
      },${JSON.stringify(message)})`;
    }
    this.messages = messages;
    this._broadcastChatMessage(
      {
        messages: messages,
        type: MessageType.CF_AGENT_CHAT_MESSAGES
      },
      excludeBroadcastIds
    );
  }

  private async _reply(id: string, response: Response) {
    // Process the v5 streaming response
    return this._tryCatchChat(async () => {
      if (!response.body) return;

      const reader = response.body.getReader();
      const messageParts: Array<
        | { type: "text"; text: string }
        | {
            type: "tool-call";
            toolCallId: string;
            toolName: string;
            args: unknown;
          }
      > = [];
      let currentTextContent = "";
      const currentToolCalls: Array<{
        toolCallId: string;
        toolName: string;
        args: unknown;
      }> = [];

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value);

          // Parse SSE format
          const lines = chunk.split("\n");
          for (const line of lines) {
            if (!line.trim()) continue;

            // Handle AI SDK v5 format ("0:" prefix)
            if (line.startsWith("0:")) {
              try {
                const jsonPart = line.slice(2);
                const parsed = JSON.parse(jsonPart);

                switch (parsed.type) {
                  case "text-delta": {
                    const text = parsed.textDelta || "";
                    currentTextContent += text;
                    // Broadcast text delta
                    this._broadcastChatMessage({
                      body: text,
                      done: false,
                      id,
                      type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
                    });
                    break;
                  }

                  case "tool-call":
                    // Collect tool calls
                    currentToolCalls.push({
                      toolCallId: parsed.toolCallId,
                      toolName: parsed.toolName,
                      args: parsed.args
                    });
                    break;

                  case "error": {
                    // Handle error events
                    const errorMessage =
                      parsed.error?.message || "An error occurred";
                    this._broadcastChatMessage({
                      body: errorMessage,
                      done: true,
                      id,
                      type: MessageType.CF_AGENT_USE_CHAT_RESPONSE,
                      error: true
                    });

                    // Save error as message part
                    await this.persistMessages([
                      ...this.messages,
                      {
                        id: crypto.randomUUID(),
                        role: "assistant",
                        parts: [{ type: "text", text: errorMessage }]
                      } as ChatMessage
                    ]);
                    return;
                  }
                }
              } catch (_e) {
                // Ignore parsing errors
              }
            }
          }
        }
      } finally {
        reader.releaseLock();
      }

      // Send completion signal
      this._broadcastChatMessage({
        body: "",
        done: true,
        id,
        type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
      });

      // Build message parts array
      if (currentTextContent) {
        messageParts.push({ type: "text", text: currentTextContent });
      }

      // Add tool calls as parts
      for (const toolCall of currentToolCalls) {
        messageParts.push({
          type: "tool-call",
          toolCallId: toolCall.toolCallId,
          toolName: toolCall.toolName,
          args: toolCall.args
        });
      }

      // Save the complete message with all parts
      await this.persistMessages([
        ...this.messages,
        {
          id: crypto.randomUUID(),
          role: "assistant",
          parts:
            messageParts.length > 0
              ? messageParts
              : [{ type: "text", text: currentTextContent || "" }]
        } as ChatMessage
      ]);
    });
  }

  /**
   * For the given message id, look up its associated AbortController
   * If the AbortController does not exist, create and store one in memory
   *
   * returns the AbortSignal associated with the AbortController
   */
  private _getAbortSignal(id: string): AbortSignal | undefined {
    // Defensive check, since we're coercing message types at the moment
    if (typeof id !== "string") {
      return undefined;
    }

    if (!this._chatMessageAbortControllers.has(id)) {
      this._chatMessageAbortControllers.set(id, new AbortController());
    }

    return this._chatMessageAbortControllers.get(id)?.signal;
  }

  /**
   * Remove an abort controller from the cache of pending message responses
   */
  private _removeAbortController(id: string) {
    this._chatMessageAbortControllers.delete(id);
  }

  /**
   * Propagate an abort signal for any requests associated with the given message id
   */
  private _cancelChatRequest(id: string) {
    if (this._chatMessageAbortControllers.has(id)) {
      const abortController = this._chatMessageAbortControllers.get(id);
      abortController?.abort();
    }
  }

  /**
   * Abort all pending requests and clear the cache of AbortControllers
   */
  private _destroyAbortControllers() {
    for (const controller of this._chatMessageAbortControllers.values()) {
      controller?.abort();
    }
    this._chatMessageAbortControllers.clear();
  }

  /**
   * When the DO is destroyed, cancel all pending requests
   */
  async destroy() {
    this._destroyAbortControllers();
    await super.destroy();
  }
}
